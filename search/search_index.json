{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Terraform+Gitlab Lunch and Learn","text":"<p>For source code visit https://gitlab.com/slalom-test/terraform-lnl</p> <p>We will cover the following topics:</p> <p></p> <ul> <li>The what and why of Terraform</li> <li>Terraform 101</li> <li>How to setup terraform locally with AWS</li> <li>Create your first terraform project</li> <li>Expand on the above project</li> <li>Integrate your project into gitlab</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>main.tf             # Initial terraform configuration\noutputs.tf          # Initial outputs file\n.gitlab-ci.yml      # Gitlab ci yaml for gitlab pipelines\nmkdocs.yml          # mkdocs configuration\n.terraform.lock.hcl # Terraform lock file\nfinal-tf-files/     # Final tf files\ndocs/\n    index.md    # The documentation homepage.\n    ...         # Other markdown pages, images and other files.\n</code></pre>"},{"location":"basic/","title":"Basic Terraform Project","text":"<p>We will start with a basic terraform project. The below terraform configures an AWS provider and creates an EC2 instance</p>"},{"location":"basic/#maintf","title":"main.tf","text":"<pre><code># main.tf\n\n# The terraform {} block contains Terraform settings, including the required \n# providers Terraform will use to provision your infrastructure\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~&gt; 4.16\"\n    }\n  }\n\n  # This is terraform version required\n  required_version = \"&gt;= 1.2.0\"\n}\n\n# Required provider requires a corresponding provider block. There can be\n# multiple provider blocks for a given provider. For example to define an AWS\n# provider for each region you plan to deploy infrastructure\nprovider \"aws\" {\n  region = \"us-west-2\"\n}\n\n# Use resource blocks to define components of your infrastructure. This is an \n# example ec2 instance\nresource \"aws_instance\" \"app_server\" {\n  ami           = \"ami-830c94e3\"\n  instance_type = \"t2.micro\"\n\n  tags = {\n    Name = \"TerraformDemo\"\n  }\n}\n</code></pre> <p>Tip</p> <p>Tag your resources whenever possible. Tags are just key/value pairs but help identify your resources and can be used for automation. Use consistent conventions for tagging. For example, <code>Environment</code> is a good tag to apply</p>"},{"location":"basic/#terraform-block","title":"terraform block","text":"<p>The <code>terraform {}</code> block contains Terraform settings, including the required providers Terraform will use to provision your infrastructure.</p>"},{"location":"basic/#aws-provider","title":"AWS Provider","text":"<p>For each provider you must configure a provider block. The provider block allows configuring settings on the provider, for example region. There can be multiple provider blocks for a given provider. For example to define an AWS provider for each region you plan to deploy infrastructure.</p>"},{"location":"basic/#resources","title":"Resources","text":"<p>Resources are what you use to configure infrastructure such as an EC2 instance</p>"},{"location":"basic/#run-terraform-init","title":"Run terraform init","text":"<p>Running terraform init will initialize the project creating local terraform state files</p> <pre><code>terraform init\n</code></pre> <p>Now I have these files</p> <pre><code>.\n\u251c\u2500\u2500 .terraform\n\u251c\u2500\u2500 .terraform.lock.hcl\n\u2514\u2500\u2500 main.tf\n</code></pre> <p>Note</p> <p>You run init to initialize a project but also need to run it when new <code>modules</code> are configured or adding new <code>providers</code></p>"},{"location":"basic/#run-terraform-fmt-and-terraform-validate","title":"Run terraform fmt and terraform validate","text":"<p>It is a good practice to run terraform format <code>fmt</code> and <code>validate</code> commands</p> <pre><code>terraform fmt -recursive\nterraform validate\n</code></pre> <p>Tip</p> <p>Good idea to run validate in your CI jobs and fmt as pre-commit hook</p>"},{"location":"basic/#run-terraform-plan","title":"Run terraform plan","text":"<p>Running terraform plan Terraform prints out the execution plan which describes the actions Terraform will take in order to change your infrastructure to match the configuration.</p> <p>You should always review the plan before applying it</p> <pre><code>terraform plan -out plan.out\n</code></pre>"},{"location":"basic/#run-terraform-apply","title":"Run terraform apply","text":"<p>This will apply the plan and create resources</p> <pre><code>terraform apply plan.out\n</code></pre>"},{"location":"gitlab/","title":"Gitlab Pipelines","text":"<p>Now lets setup a gitlab pipeline to run Terraform!</p>"},{"location":"gitlab/#gitlab-ciyml","title":".gitlab-ci.yml","text":"<p>Info</p> <p>Gitlab pipelines are configured via a yaml file called <code>.gitlab-ci.yml</code></p> <p>First step is we will need to configure our <code>.gitlab-ci.yml</code></p> <p>Tip</p> <p>Gitlab also needs to access your AWS account. There are several ways to do this. The easiest being setting CI/CD variables for <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code>. However, there are more secure ways and your client may have already integrated AWS with Gitlab</p> <p>Configure below in <code>.gitlab-ci.yml</code> file</p> <pre><code>include:\n  - template: Terraform.latest.gitlab-ci.yml\n</code></pre> <p>Wait, that is it? Yes. Gitlab has all the jobs necessary in the above template</p> <p>Ok lets push this to gitlab and see what happens</p> <pre><code>git checkout -b feature/demo-gitlab\ngit commit -am\"fix: add .gitlab-ci.yml\"\ngit push gitlab\n</code></pre> <p>You should see</p> <p></p> <p>Gitlab runs these jobs</p> <ul> <li>validate: <code>terraform validate</code></li> <li>fmt: <code>terraform fmt</code></li> <li>kics-iac-sast: a static scan for IaC code</li> <li>build: <code>terraform plan</code></li> </ul> <p>Warning</p> <p>It runs a plan successfully but terraform wants to re-create all the resources</p> <p>When Terraform runs in Gitlab it doesn't know about the resources we have created because we have been using local state. Lets fix that!</p>"},{"location":"gitlab/#configure-terraform-to-use-remote-backend","title":"Configure terraform to use remote backend","text":"<p>In <code>main.tf</code> update the <code>terraform</code> block to include the below. This tells terraform to use a remote http backend to store state</p> <pre><code>  backend \"http\" {\n  }\n</code></pre> <p>Now we need to migrate our local state to gitlab. You need to create a gitlab personal access token to do this, see https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html</p> <p>Note</p> <p>Token needs to have <code>api</code> scope</p> <p>The script below will instruct terraform to init with remote state. We only need to do this once. You set the <code>PROJECT_ID</code> to the corresponding gitlab project and <code>TF_USERNAME</code> to your gitlab username and <code>TF_PASSWORD</code> to your gitlab personal access token</p> <pre><code>PROJECT_ID=\"45873656\"\nTF_USERNAME=\"travis.redfield\"\nTF_PASSWORD=\"$(pass /work/slalom/gitlab/travis.redfield/token)\"\nTF_ADDRESS=\"https://gitlab.com/api/v4/projects/${PROJECT_ID}/terraform/state/default\"\n\nterraform init \\\n  -backend-config=address=${TF_ADDRESS} \\\n  -backend-config=lock_address=${TF_ADDRESS}/lock \\\n  -backend-config=unlock_address=${TF_ADDRESS}/lock \\\n  -backend-config=username=${TF_USERNAME} \\\n  -backend-config=password=${TF_PASSWORD} \\\n  -backend-config=lock_method=POST \\\n  -backend-config=unlock_method=DELETE \\\n  -backend-config=retry_wait_min=5\n</code></pre> <p>You should see similar output. When terraform asks to copy your local state to new \"http\" backend answer <code>yes</code></p> <pre><code>Initializing the backend...\nDo you want to copy existing state to the new backend?\n  Pre-existing state was found while migrating the previous \"local\" backend to the\n  newly configured \"http\" backend. No existing state was found in the newly\n  configured \"http\" backend. Do you want to copy this state to the new \"http\"\n  backend? Enter \"yes\" to copy and \"no\" to start with an empty state.\n\n  Enter a value: yes\n\n\nSuccessfully configured the backend \"http\"! Terraform will automatically\nuse this backend unless the backend configuration changes.\n\nInitializing provider plugins...\n- Reusing previous version of hashicorp/tls from the dependency lock file\n- Reusing previous version of hashicorp/aws from the dependency lock file\n- Using previously-installed hashicorp/tls v4.0.4\n- Using previously-installed hashicorp/aws v4.66.1\n\nTerraform has been successfully initialized!\n</code></pre> <p>Now push updated files to gitlab</p> <pre><code>git commit -am\"fix: updating remote backend\"\ngit push gitlab\n</code></pre> <p>Now gitlab should show no changes in the plan because it has the correct state</p>"},{"location":"gitlab/#add-a-new-resource-and-apply-with-gitlab","title":"Add a new resource and apply with gitlab","text":"<p>Lets add a new resource and let gitlab apply it</p> <p>First add below to <code>main.tf</code>. This will create and <code>S3</code> bucket</p> <pre><code># create an S3 bucket\nresource \"aws_s3_bucket\" \"example\" {\n  bucket = \"terraform-lnl-test-bucket\"\n\n  tags = {\n    Name = \"TerraformDemo\"\n  }\n}\n</code></pre> <p>Push to gitlab</p> <pre><code>git commit -am\"fix: configure s3 bucket\"\ngit push gitlab\n</code></pre> <p>The plan in gitlab should show creating an S3 bucket</p> <pre><code>Plan: 1 to add, 0 to change, 0 to destroy.\n</code></pre> <p>Create a merge request and merge to main. The pipeline should look like below</p> <p></p> <p>The <code>deploy</code> job runs <code>terraform apply</code>. It is manual job. Click play button to run it. The output should show</p> <pre><code>aws_s3_bucket.example: Creating...\naws_s3_bucket.example: Creation complete after 3s [id=terraform-lnl-test-bucket]\nApply complete! Resources: 1 added, 0 changed, 0 destroyed.\n</code></pre>"},{"location":"gitlab/#destroy-resources","title":"Destroy Resources","text":"<p>The great thing about terraform is that you can easily destroy all the resources you have created. When doing a poc or demo this is great feature!</p> <pre><code>terraform plan -destroy -out=plan.out\n</code></pre> <p>You should see output</p> <pre><code>Plan: 0 to add, 0 to change, 5 to destroy.\n</code></pre> <p>Now run apply</p> <pre><code>terraform apply plan.out\n</code></pre>"},{"location":"q-n-a/","title":"Questions and Answers","text":"<p>That is it, any questions?</p>"},{"location":"q-n-a/#references","title":"References","text":"<ul> <li>Terraform https://www.terraform.io/</li> <li>Terraform VS Code Extension https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform</li> <li>Tutorials https://developer.hashicorp.com/terraform/tutorials</li> <li>Great Tools for Terraform https://gruntwork.io/</li> </ul>"},{"location":"setup/","title":"Setup","text":"<p>Below are steps for basic terraform setup locally</p> <p>I highly recommend you use a package manager such as <code>brew</code> for mac or <code>choco</code> for windows.</p> <p>See:</p> <ul> <li>https://chocolatey.org/install</li> <li>https://brew.sh/</li> </ul>"},{"location":"setup/#install-terraform","title":"Install Terraform","text":"<pre><code># mac\nbrew tap hashicorp/tap\nbrew install hashicorp/tap/terraform\nbrew install jq\n</code></pre> <pre><code># windows\nchoco install terraform\nchoco install jq\n</code></pre> <p>Tip</p> <p>VS Code has great terraform extensions. A must is <code>HashiCorp Terraform</code> extension</p>"},{"location":"setup/#local-aws-setup","title":"Local AWS Setup","text":"<p>For running terraform locally you need to provide credentials for most Terraform providers. This typically can be done via environment variables. Here is how to setup AWS</p> <p>Tip</p> <p>I use https://www.passwordstore.org below for retrieving secrets locally</p> <p>Export AWS credentials</p> <pre><code>export AWS_ACCESS_KEY_ID=AKIAQINXMUNZQOZILKJS\nexport AWS_SECRET_ACCESS_KEY=$(pass /work/slalom/TerraformDemo/AKIAQINXMUNZQOZILKJS)\n</code></pre> <p>Warning</p> <p>Using AWS user access keys is not very secure because they are long lived and can be leaked. There are several approaches to retrieve temporary credentials. Work with your client to make sure you are using the most secure approach</p>"},{"location":"tf-101/","title":"Terraform 101","text":""},{"location":"tf-101/#terraform-hcl","title":"Terraform HCL","text":"<p>Terraform is written in HCL (Hashicorp Configuration Language). Which is very JSON like but more human readable</p> <p>An example resource to create an EC2 instance</p> <pre><code>resource \"aws_instance\" \"app_server\" {\n  ami           = \"ami-830c94e3\"\n  instance_type = \"t2.micro\"\n\n  tags = {\n    Name = \"TerraformDemo\"\n  }\n}\n</code></pre>"},{"location":"tf-101/#terraform-basic-workflow","title":"Terraform Basic Workflow","text":"<ul> <li>You write your infrastructure in configuration files (.tf files)</li> <li>You run the \"init\" command to initialize terraform</li> <li>You run the \u201cplan\u201d command<ul> <li>Terraform analyzes the infrastructure compared to your configuration and creates a plan that will create, update, or destroy resources as necessary</li> </ul> </li> <li>After reviewing the plan, you run the \u201capply\u201d command. Terraform executes the plan</li> </ul>"},{"location":"tf-101/#terraform-state","title":"Terraform State","text":"<p>The primary purpose of Terraform state is to store bindings between objects in a remote system and resource instances declared in your configuration</p> <ul> <li>keep track of metadata</li> <li>determine which changes to make to your infrastructure</li> <li>improve performance for large infrastructures</li> </ul> <p>Tip</p> <p>Remote state allows teams to work together while using remote locking as a measure to avoid two or more different users accidentally running Terraform at the same time, and thus ensure that each Terraform run begins with the most recent updated state.</p>"},{"location":"tf-101/#terraform-providers-and-modules","title":"Terraform Providers and Modules","text":"<ul> <li>Providers  are the plugins that Terraform uses to manage resources. Every supported service or infrastructure platform has a provider that defines which resources are available and performs API calls to manage those resources.</li> <li>Modules are reusable Terraform configurations that can be called and configured by other configurations. Most modules manage a few closely related resources from a single provider. You can create your own modules or use modules from the Terraform registry</li> </ul> <p>Note</p> <p>We won't cover modules but they are a great way create re-useable building blocks when creating your infrastructure and highly encourage you to learn about modules</p>"},{"location":"update-and-add/","title":"Update and Add Resources","text":"<p>Lets update our EC2 instance and add a private key pair so we can ssh into it.</p>"},{"location":"update-and-add/#add-a-private-key","title":"Add a private key","text":"<p>Add the resources below to configure a key</p> <pre><code># Creates a private key\nresource \"tls_private_key\" \"this\" {\n  algorithm = \"RSA\"\n}\n\n# Creates an AWS key pair for ec2 instance\nresource \"aws_key_pair\" \"this\" {\n  key_name   = \"tf-demo\"\n  public_key = tls_private_key.this.public_key_openssh\n}\n</code></pre> <p>Now add the following to <code>aws_instance</code></p> <pre><code>  key_name      = aws_key_pair.this.key_name\n</code></pre> <p>Add the following to outputs.tf to retrieve the private key from terraform</p> <p>Warning</p> <p>It is not recommended to add a private key to output for production application</p> <pre><code>output \"private_key_pem\" {\n  value     = tls_private_key.this.private_key_pem\n  sensitive = true\n}\n</code></pre> <p>Run terraform fmt, validate</p> <pre><code>terraform fmt\nterraform validate\n</code></pre> <p>Run terraform plan</p> <pre><code>terraform plan -out=plan.out\n</code></pre>"},{"location":"update-and-add/#add-security-group-for-ssh-access","title":"Add security group for ssh access","text":"<p>Create a security group to control what requests can go in and out of the ec2 instance by adding below to <code>main.tf</code></p> <pre><code># Security group to allow ssh\nresource \"aws_security_group\" \"this\" {\n  name = \"sg_tf_demo\"\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port = 22\n    to_port   = 22\n    protocol  = \"tcp\"\n\n    # To keep this example simple, we allow incoming SSH requests from any IP. \n    # In real-world usage, you should only allow SSH requests from trusted \n    # servers, such as a bastion host or VPN server.\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n</code></pre> <p>Update ec2 instance <code>app_server</code> in <code>main.tf</code> to be public accessible and configure security group to allow ssh</p> <pre><code>  # This EC2 Instance has a public IP and will be accessible directly from \n  # the public Internet\n  associate_public_ip_address = true\n\n  # Security groups for ssh\n  vpc_security_group_ids = [\"${aws_security_group.this.id}\"]  \n</code></pre> <p>Add the public dns to <code>outputs.tf</code></p> <pre><code>output \"public_dns\" {\n  value = aws_instance.app_server.public_dns\n}\n</code></pre> <p>Run terraform fmt, validate</p> <pre><code>terraform fmt\nterraform validate\n</code></pre> <p>Now re-run terraform plan</p> <pre><code>terraform plan -out plan.out\n</code></pre> <p>And terraform apply</p> <pre><code>terraform apply plan.out\n</code></pre> <p>Create the pem file using private key output from terraform</p> <pre><code>terraform output -json | jq -r '.private_key_pem.value' &gt; tf-demo.pem\nchmod 400 tf-demo.pem\n</code></pre> <p>Connect to ec2 instance retrieving DNS from terraform</p> <pre><code>ssh -i \"tf-demo.pem\" ubuntu@$(terraform output -json | jq -r '.public_dns.value')\n</code></pre>"},{"location":"what-is-tf/","title":"What is Terraform","text":"<p>Terraform is an Infrastructure as Code tool that automates creating your infrastructure</p> <ul> <li>Terraform allows you to write code to configure your infrastructure. This is referred to Infrastructure as Code (IAC)</li> <li>With <code>IaC</code> you \u201cdeclare\u201d how you want your infrastructure to be. Tools like Terraform make it so</li> <li>This is much different than how tools of the past provisioned infrastructure that more or less used scripts or \u201cinstructions\u201d. Older tools are usually procedural</li> <li>You work with Terraform via a CLI (command line interface) but often it is used in automation CI/CD platforms</li> </ul> <pre><code>\u276f terraform\nUsage: terraform [global options] &lt;subcommand&gt; [args]\n\nThe available commands for execution are listed below.\nThe primary workflow commands are given first, followed by\nless common or more advanced commands.\n\nMain commands:\n  init          Prepare your working directory for other commands\n  validate      Check whether the configuration is valid\n  plan          Show changes required by the current configuration\n  apply         Create or update infrastructure\n  destroy       Destroy previously-created infrastructure\n</code></pre>"},{"location":"why-choose-tf/","title":"Why Choose Terraform","text":"<p>What about CloudFormation, CDK, Pulumi?</p> <ul> <li>CloudFormation and AWS Cloud Development Kit (CDK) are viable tools if you are only working with AWS</li> <li>Terraform has the advantage of being cloud agnostic and allows you to provision across multiple cloud providers</li> <li>Terraform also works for more than just provisioning infrastructure:<ul> <li>Manage Kubernetes</li> <li>Salesforce</li> <li>On-prem resources</li> <li>Databases</li> <li>Security and Authentication</li> <li>Policy as Code</li> <li>Much more!</li> </ul> </li> <li>Terraform now has CDK! This allows you to write terraform in TypeScript, Python, Java, C#, and Go</li> <li>What about Pulumi? Pulumi is a great choice as well. Similar to CDK Pulumi allows you to write infrastructure in many programming languages</li> </ul>"},{"location":"why-tf/","title":"Why Use Terraform","text":"<p>Writing terraform code your first time is probably going to seem like a PITA, why not just use the console?</p> <ul> <li>As it is an automated process, it is more consistent, repeatable, and has fewer chances of errors</li> <li>Terraform gives you a chance to review the changes that will be made before they are applied. And changes are easy to rollback</li> <li>In a disaster you can easily recover an environment in very little time</li> <li>Terraform prevents infrastructure drift</li> <li>Being it is code, you check it into git and have the same accountability, history, etc</li> </ul> <p>Success</p> <p>Your client will think you are a superhero when they ask if you can create yet another new environment and you say \u201cyes, just give me a few minutes\u201d</p>"}]}